task:
  translate
data_path:
  data/ProofWriter/train.json
output_dir:
  outputs/deepseek-chat/ProofWriter/translation/train
prompts:
  # ${chat_history} 之前的放在system, 之后的放在user
  prompt: &prompt |-
    You are given a logic problem including a context and a question as follows:
    Context: ${context}
    Question: ${question}
    From your perspective, please give your understanding of the question and context,and discuss with your opponent about the parsing of the question.
    Think about the advantages and disadvantages of each language, and keep the original format of each language, correct the current language by referring to other languages.
    Here is your discussion history:
    ${chat_history} 
    ${role_description}
    ${turn_specific_instruction}

llm_config:
  # 模式选择: 'api' 使用API调用, 'local' 使用本地LLM
  mode: 'api'  # 可选: 'api' 或 'local'
  
  # API模式配置
  api_settings:
    model: "gpt-4.1" # "deepseek-chat"    # API调用的模型名称，直接传递给OpenAI兼容的API, 在 agentverse/llms/openai.py 中，通过 client.chat.completions.create(messages=messages, **self.args.dict()) 调用时，model 字段会被传递给API服务器
    llm_type: "gpt-4.1" #"deepseek-chat"  # LLM类选择：在 agentverse/initialization.py 的 load_llm() 函数中，通过 llm_registry.build(llm_type, **llm_config) 来选择具体的LLM实现类   注册系统：通过装饰器 @llm_registry.register() 将不同的LLM类注册到系统中
    temperature: 0
    max_tokens: 512
    max_retry: 3
    
  # 本地LLM模式配置  
  local_settings:
    model_path: "/mnt/sdb/ssuser/llm_models/Deepseek-14B"
    llm_type: "deepseek-local"
    temperature: 0.7
    top_p: 0.9
    top_k: 50
    max_tokens: 5120
    tensor_parallel_size: 1
    gpu_memory_utilization: 0.9
    max_model_len: 4096
    trust_remote_code: true
    max_retry: 3

environment:
  env_type: llm_eval
  max_turns: 3    # 必须是3的倍数
  rule:
    order:
      type: sequential
    visibility:
      type: all
    selector:
      type: basic
    updater:
      type: basic
    describer:
      type: basic

agents:
  -
    agent_type: llm_eval_multi
    name: LP translator
    final_prompt_to_use: |-
      After discussion, now you need to give your final output. Return **only** Predicates, Facts, Rules, and Query.
    normal_turn_instruction: |-
      Now it's your turn to speak. Please speak as concisely and clearly as possible, ${agent_name} !
    role_description: |-
      You are given a problem description and a question. The task is to:
      1. define all the predicates in the problem
      2. parse the problem into logic rules based on the defined predicates
      3. write all the facts mentioned in the problem
      4. parse the question into the logic form
      ----------------
      Example:
      Context: Each jompus is fruity.
      (... more context here ...)
      Rompuses are zumpuses. Alex is a tumpus.

      Question: True or false: Alex is not shy.

      Predicates:
      Jompus($x, bool) ::: Does x belong to Jompus?
      (... more predicates here ...)
      Zumpus($x, bool) ::: Does x belong to Zumpuses?

      Facts:
      Tumpuses(Alex, True)

      Rules:
      Jompus($x, True) >>> Fruity($x, True)
      (... more rules here ...)
      Dumpus($x, True) >>> Rompus($x, True)

      Query:
      Shy(Alex, False)
    memory:
      memory_type: chat_history
    memory_manipulator:
      memory_manipulator_type: basic
    prompt_template: *prompt
  -
    agent_type: llm_eval_multi
    name: FOL translator
    final_prompt_to_use: |-
      After discussion, now you need to give your final output.Return **only** Predicates, Premises, and Conclusion.
    normal_turn_instruction: |-
      Now it's your turn to speak. Please speak as concisely and clearly as possible, ${agent_name} !
    role_description: |-
       Task Description: Given a problem description and a question. The task is to parse the problem and the question into first-order logic formulas. The grammar of first-order logic is defined as follows:

        logical conjunction: expr1 ∧ expr2
        logical disjunction: expr1 ∨ expr2
        logical exclusive disjunction: expr1 ⊕ expr2
        logical negation: ¬expr1
        expr1 implies expr2: expr1 → expr2
        expr1 if and only if expr2: expr1 ↔ expr2
        logical universal quantification: ∀ x
        logical existential quantification: ∃ x
        Output format: logic form ::: description

        ---------------
        Example：
        Context: All people who regularly drink coffee are
        dependent on caffeine.
        (... more context here ...)
        If Rina is not a person dependent on caffeine and a
        student, then Rina is either a person dependent
        on caffeine and a student, or a person dependent
        on caffeine nor a student, or neither a person
        dependent on caffeine nor a student.

        Question: Based on the above information, is the
        following statement true, false, or uncertain?
        Rina is either a person who jokes about being
        addicted to caffeine or is unaware that caffeine
        is a drug.

        Predicates:
        Dependent(x) ::: x is a person dependent on caffeine
        (... more predicates here ...)
        Student(x) ::: x is a student

        Premises:
        ∀x (Drinks(x) → Dependent(x)) ::: All people who
        regularly drink coffee are dependent on caffeine.

        (... more premises here ...)
        ∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes
        about being addicted to caffeine is unaware that
        caffeine is a drug.

        Conclusion:
        Jokes(rina) ⊕ Unaware(rina) ::: Rina is either a
        person who jokes about being addicted to caffeine
        or is unaware that caffeine is a drug.into a language that is understandable to the user.
    memory:
      memory_type: chat_history
    memory_manipulator:
      memory_manipulator_type: basic
    prompt_template: *prompt

  -
    agent_type: llm_eval_multi
    name: CSP translator
    final_prompt_to_use: |-
      After discussion, now you need to give your final output. Return **only** domain, variables, and constraints. 
    normal_turn_instruction: |-
      Now it's your turn to speak. Please speak as concisely and clearly as possible, ${agent_name} !
    role_description: |-
      Task Description: You are given a problem description.
      The task is to parse the problem as a constraint satisfaction problem, defining the domain, variables, and constraints.

      -----------
      Example：
      Context: The following paragraphs each describe a
      set of three objects arranged in a fixed order.
      (... more context here ...)
      The minivan is newer than the convertible.

      Question: Which of the following is true?

      Options:
      A) The station wagon is the second-newest.
      B) The convertible is the second-newest.
      C) The minivan is the second-newest.

      Domain:
      1: oldest
      3: newest

      Variables:
      station_wagon [IN] [1, 2, 3]
      convertible [IN] [1, 2, 3]
      minivan [IN] [1, 2, 3]

      Constraints:
      station_wagon == 1 ::: The station wagon is the oldest.
      minivan > convertible ::: The minivan is newer than the convertible.
      AllDifferentConstraint([station_wagon, convertible, minivan]) ::: All vehicles have different values.

      Query:
      A) station_wagon == 2 ::: The station wagon is the second-newest.
      B) convertible == 2 ::: The convertible is the second-newest.
      C) minivan == 2 ::: The minivan is the second-newest.

    memory:
      memory_type: chat_history
    memory_manipulator:
      memory_manipulator_type: basic
    prompt_template: *prompt

tools: ~ 