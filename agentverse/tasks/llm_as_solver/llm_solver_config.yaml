task:
  llm_solver
data_path:
  data/ProofWriter/train.json
output_dir: 
  outputs/deepseek-chat/ProofWriter/llm_solver/train

# ---------- Execution Settings ----------
execution:
  # Enable role-level concurrency for each question
  enable_role_concurrency: true
  # Maximum number of concurrent roles per question
  max_concurrent_roles: 3
  # number of questions to process (0 = all)
  max_questions: 20

# ---------- LLM Configuration ----------
llm_config:
  mode: 'api' # local or api
  
  api_settings:
    model: "deepseek-chat"
    llm_type: "deepseek-chat"
    temperature: 0.1
    max_tokens: 2048
    top_p: 0.95
    max_retry: 3
    
  local_settings:
    model_path: "/mnt/sdb/ssuser/llm_models/Deepseek-14B"
    llm_type: "deepseek-local"
    temperature: 0.1
    top_p: 0.95
    top_k: 40
    max_tokens: 1024
    tensor_parallel_size: 1
    gpu_memory_utilization: 0.9
    max_model_len: 4096
    trust_remote_code: true

# ---------- Output Parser Configuration ----------
# Note: parser_type is now specified per role below

# ---------- Prompt Templates ----------
prompt_templates:
  cot_prompt: &cot_prompt |-
    You are given a logic problem that contains a context, a question, and multiple-choice options.

    [Logic Problem]
    Context: ${context}
    Question: ${question}
    Options:
    ${options}

    ${role_description}
    
    ${instruction}

    Return **only** your final choice in the format:
    <answer>ANSWER_LETTER<reason>YOUR_REASONING

    Example:
    <answer>B<reason>Based on the provided facts and rules, the statement "The tiger is not young" is **unknown**. None of the given rules allow us to confirm or deny the tiger's age, so the correct choice is "Unknown".

  plan_and_solve_prompt: &plan_and_solve_prompt |-
    Q: ${context}
    ${question}
    ${options}
    A: ${instruction}

# ---------- Role Definitions ----------
roles:
  - name: "cot_solver"
    display_name: "COT Solver"
    parser_type: "cot"
    role_description: |-
      You are an intelligent forward reasoner who performs strict deductive reasoning from premises to conclusion.
    instruction: |-
      Follow the chain "Premise → Rule → Conclusion".
      1. Extract explicit rules and facts from the text.
      2. Derive intermediate statements step by step.
      3. Produce the final answer and include your reasoning trace.

      Example approach:
      • Extracted rules:
          (1) Mammal → Vertebrate
          (2) Vertebrate → Has Skeleton
          (3) Cat is a mammal
      • Reasoning:
          - From (3) and (1): Cat is a vertebrate.
          - From "Cat is a vertebrate" and (2): Cat has a skeleton.
      • Output:
          <answer>A<reason>The cat must have a skeleton because it is a mammal, and all mammals are vertebrates, and all vertebrates have skeletons.
    prompt_template: *cot_prompt

  - name: "plan-and-solve"
    display_name: "Plan-and-Solve"
    agent_type: "plan_and_solve"
    parser_type: "plan_and_solve"
    role_description: ""
    instruction: |-
      Let's first understand the problem and devise a plan to solve the problem. Then, let's carry out the plan to solve the problem step by step.
    extraction_trigger: "Therefore, the answer is (return a single answer letter in the format <answer>ANSWER_LETTER<answer/>)"
    prompt_template: *plan_and_solve_prompt



